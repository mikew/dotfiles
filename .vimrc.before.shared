call janus#disable_plugin('buffergator')
call janus#disable_plugin('snipmate')
"call janus#disable_plugin('supertab')

set mouse=a

" Use matcher for Ctrl+P
let g:path_to_matcher = "/usr/local/bin/matcher"

let g:ctrlp_user_command = ['.git/', 'cd %s && git ls-files . -co --exclude-standard']

let g:ctrlp_match_func = { 'match': 'GoodMatch' }

function! GoodMatch(items, str, limit, mmode, ispath, crfile, regex)

  " Create a cache file if not yet exists
  let cachefile = ctrlp#utils#cachedir().'/matcher.cache'
  if !( filereadable(cachefile) && a:items == readfile(cachefile) )
    call writefile(a:items, cachefile)
  endif
  if !filereadable(cachefile)
    return []
  endif

  " a:mmode is currently ignored. In the future, we should probably do
  " something about that. the matcher behaves like "full-line".
  let cmd = g:path_to_matcher.' --limit '.a:limit.' --manifest '.cachefile.' '
  if !( exists('g:ctrlp_dotfiles') && g:ctrlp_dotfiles )
    let cmd = cmd.'--no-dotfiles '
  endif
  let cmd = cmd.a:str

  return split(system(cmd), "\n")

endfunction

" Use git ls-files for Ctrl+P
"let g:ctrlp_working_path_mode = 'r'
"let g:ctrlp_custom_ignore = {
"    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
"    \ 'file': '\.exe$\|\.so$\|\.dll$' }
"
"let g:ctrlp_user_command = {
"    \ 'types': {
"        \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
"        \ 2: ['.hg', 'hg --cwd %s locate -I .'],
"    \ },
"    \ 'fallback': 'find %s -type f'
"\ }

let g:airline_powerline_fonts = 1

" Highlight line and cursor
set cursorline
"set cursorcolumn

" Highlight word under cursor like IDEs
"autocmd! CursorMoved * exe printf('match IncSearch /\V\<%s\>/', escape(expand('<cword>'), '/\'))

" https://github.com/klen/python-mode#settings
"let g:pymode = 1
let g:pymode_doc = 0
"let g:pymode_run = 1
"let g:pymode_lint = 1
let g:pymode_rope = 0
let g:pymode_folding = 0
let g:pymode_syntax = 1
let g:pymode_syntax_all = 1
"let g:python_highlight_all = 1
"let g:pymode_syntax_highlight_self = g:pymode_syntax_all
let g:pymode_lint_write = 0

" E125: Makes indenting seem inconsistent with E128.
" E128: You run into E501 much quicker.
" E501: Django makes it really hard to keep lines short.
let g:pymode_lint_ignore = "E501,E125,E128"
"let g:pymode_lint_checker = "pyflakes"

" Highlighting for .pys files (used in Plex)
autocmd BufNewFile,BufEnter *.pys set ft=python
"autocmd filetype python syn keyword pythonBuiltinObj self cls

set shiftwidth=2
set softtabstop=2
set background=dark
set noshowmode
set iskeyword=@,48-57,_,192-255,-

" Indent Guides
"let g:indent_guides_start_level = 3
"let g:indent_guides_guide_size = 1
"let g:indent_guides_enable_on_vim_startup = 1
"let g:indent_guides_color_change_percent = 5

" Indent Lines
let g:indentLine_enabled = 1
let g:indentLine_faster = 1
"let g:indentLine_char = 'â”†'

" Highlight over 80 characters
set colorcolumn=80

" No bells
set noerrorbells visualbell t_vb=
autocmd GUIEnter * set visualbell t_vb=

"set list listchars=tab:â–·â‹…,trail:â‹…,nbsp:â‹…

" YouCompleteMe
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_server_log_level = 'debug'
let g:ycm_complete_in_comments = 1
"let g:ycm_filetype_whitelist = { 'cs': 1 }
"let g:ycm_filetype_specific_completion_to_disable = { 'cs': 1 }
let g:ycm_collect_identifiers_from_tags_files = 1
"let g:ycm_key_invoke_completion = '<S-Tab>'
"let g:ycm_key_invoke_completion = '<c-space>'
"set completeopt-=preview

nnoremap <C-]> :execute 'tj' expand('<cword>')<CR>zv

filetype plugin on
set omnifunc=syntaxcomplete#Complete
"if has("autocmd") && exists("+omnifunc")
  "autocmd Filetype *
        "\ if &omnifunc == "" |
        "\   setlocal omnifunc=syntaxcomplete#Complete |
        "\ endif
"endif

" SuperTab
"let g:SuperTabDefaultCompletionType = "<C-X><C-O>"
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabContextDiscoverDiscovery =
    \ ["&completefunc:<c-x><c-u>", "&omnifunc:<c-x><c-o>"]

" Add cwd to vim python path
python <<EOF
import sys
import vim
try:
  sys.path.insert(0, vim._getcwd())
except:
  pass
EOF

" Easily generate UUIDs
fu! GenerateUUID()
python << EOF
import uuid
import vim

# output a uuid to the vim variable for insertion below
vim.command("let generatedUUID = \"%s\"" % str(uuid.uuid4()))
EOF

" insert the python generated uuid into the current cursor's position
:execute "normal i" . generatedUUID . ""
endfunction

" initialize the generateUUID function here and map it to a local command
noremap <Leader>r :call GenerateUUID()<CR>
